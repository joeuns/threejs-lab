<!-- 유저 상호작용 추가 토네이도 -->

<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Three.js Tornado – interactive</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        background: #0b0f14;
        color: #dbe5ff;
        font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
          Helvetica, Arial;
      }
      #app {
        position: fixed;
        inset: 0;
      }
      .hint {
        position: fixed;
        left: 12px;
        bottom: 12px;
        opacity: 0.75;
        font-size: 12px;
        line-height: 1.35;
      }
      .hint kbd {
        background: #111827;
        border: 1px solid #394151;
        border-bottom-width: 2px;
        border-radius: 6px;
        padding: 2px 6px;
        font-weight: 600;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>
    <div class="hint">
      드래그: 회전 · 휠: 줌 · <kbd>R</kbd>: 리셋 · <kbd>Space</kbd>: 정지/재생 ·
      마우스: 입자 회피
    </div>

    <script type="module">
      // --- Imports
      import * as THREE from "three";
      import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
      import GUI from "lil-gui";

      // --- Renderer / Scene / Camera
      const container = document.getElementById("app");
      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: false,
      });
      renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      container.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x0b0f14, 0.015);

      const camera = new THREE.PerspectiveCamera(
        55,
        window.innerWidth / window.innerHeight,
        0.1,
        500
      );
      camera.position.set(10, 7, 16);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.06;
      controls.target.set(0, 5, 0);

      // --- Lights
      const hemi = new THREE.HemisphereLight(0xbcd3ff, 0x090b10, 0.7);
      scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xaec8ff, 1.25);
      dir.position.set(-6, 12, 6);
      dir.castShadow = true;
      dir.shadow.camera.top = 16;
      dir.shadow.camera.bottom = -8;
      dir.shadow.camera.left = -12;
      dir.shadow.camera.right = 12;
      scene.add(dir);

      // --- Ground
      const ground = new THREE.Mesh(
        new THREE.CircleGeometry(14, 64),
        new THREE.MeshStandardMaterial({
          color: 0x0d1420,
          roughness: 1,
          metalness: 0,
        })
      );
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // --- Tornado parameters
      const params = {
        height: 10,
        baseRadius: 6,
        topRadius: 2,
        particles: 6000,
        swirl: 1.6,
        updraft: 2.0,
        wobble: 0.6,
        innerBoost: 1.6,
        color: "#a8c7ff",
        dust: true,
        pulse: 0.15,
      };

      // --- Interaction parameters
      const interaction = {
        enabled: true,
        radius: 1.2, // 마우스 영향 반경 (월드 단위)
        strength: 0.75, // 반발 세기(가까울수록 강해짐)
        falloff: 2.0, // 거리 감쇠 지수(2~3 권장)
        lerp: 0.25, // hover 지점 보간 정도
      };

      // --- Utility: cone radius at given height (y = 0..height)
      const radiusAt = (y) => {
        const t = y / params.height; // 0(bottom) -> 1(top)
        return THREE.MathUtils.lerp(params.topRadius, params.baseRadius, t);
      };

      // --- Create tornado particle system
      const positions = new Float32Array(params.particles * 3);
      const speeds = new Float32Array(params.particles);
      const heights = new Float32Array(params.particles);
      const radii = new Float32Array(params.particles);

      const rnd = (a = 0, b = 1) => a + Math.random() * (b - a);

      for (let i = 0; i < params.particles; i++) {
        const y = rnd(0, params.height);
        const r = radiusAt(y) * rnd(0.88, 1.02);
        const a = rnd(0, Math.PI * 2);
        const x = Math.cos(a) * r;
        const z = Math.sin(a) * r;
        const idx = i * 3;
        positions[idx] = x;
        positions[idx + 1] = y;
        positions[idx + 2] = z;
        heights[i] = y;
        radii[i] = r;
        const innerFactor = THREE.MathUtils.clamp(
          1 - r / (params.baseRadius + 0.0001),
          0.05,
          1.0
        );
        speeds[i] = rnd(0.8, 1.2) * (1 + params.innerBoost * innerFactor);
      }

      const geom = new THREE.BufferGeometry();
      geom.setAttribute("position", new THREE.BufferAttribute(positions, 3));

      const mat = new THREE.PointsMaterial({
        size: 0.08,
        color: new THREE.Color(params.color),
        transparent: true,
        opacity: 0.9,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: true,
      });

      const tornado = new THREE.Points(geom, mat);
      tornado.castShadow = false;
      scene.add(tornado);

      // --- Dust ring near ground
      const dustGeom = new THREE.BufferGeometry();
      const dustCount = 1200;
      const dustPos = new Float32Array(dustCount * 3);
      const dustAng = new Float32Array(dustCount);
      const dustRad = new Float32Array(dustCount);
      for (let i = 0; i < dustCount; i++) {
        dustAng[i] = rnd(0, Math.PI * 2);
        dustRad[i] = rnd(params.baseRadius * 0.7, params.baseRadius * 1.1);
        const idx = i * 3;
        dustPos[idx] = Math.cos(dustAng[i]) * dustRad[i];
        dustPos[idx + 1] = rnd(0.02, 0.3);
        dustPos[idx + 2] = Math.sin(dustAng[i]) * dustRad[i];
      }
      dustGeom.setAttribute("position", new THREE.BufferAttribute(dustPos, 3));
      const dustMat = new THREE.PointsMaterial({
        size: 0.06,
        color: 0x9fb6ff,
        transparent: true,
        opacity: 0.35,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
      });
      const dust = new THREE.Points(dustGeom, dustMat);
      dust.visible = params.dust;
      scene.add(dust);

      // --- Subtle volumetric look: billboarded sprites as shell layers
      const shellGroup = new THREE.Group();
      const shellLayers = 5;
      for (let i = 0; i < shellLayers; i++) {
        const r = params.baseRadius * (0.65 - i * 0.08);
        const h = params.height * (0.9 - i * 0.1);
        const tex = new THREE.CanvasTexture(makeNoiseCanvas(256));
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        const m = new THREE.MeshBasicMaterial({
          map: tex,
          transparent: true,
          opacity: 0.12,
          depthWrite: false,
          blending: THREE.AdditiveBlending,
        });
        const g = new THREE.PlaneGeometry(r * 2.2, h * 1.05, 1, 1);
        const mesh = new THREE.Mesh(g, m);
        mesh.position.y = h * 0.5;
        shellGroup.add(mesh);
      }
      scene.add(shellGroup);

      function makeNoiseCanvas(size) {
        const c = document.createElement("canvas");
        c.width = c.height = size;
        const ctx = c.getContext("2d");
        const img = ctx.createImageData(size, size);
        for (let i = 0; i < img.data.length; i += 4) {
          const v = Math.random() * 255;
          img.data[i] = img.data[i + 1] = img.data[i + 2] = v;
          img.data[i + 3] = Math.random() * 120;
        }
        ctx.putImageData(img, 0, 0);
        return c;
      }

      // --- Interaction collider (invisible cylinder)
      const interactionCollider = new THREE.Mesh(
        new THREE.CylinderGeometry(
          params.baseRadius * 1.05,
          params.topRadius * 1.05,
          params.height,
          24,
          1,
          true
        ),
        new THREE.MeshBasicMaterial({ visible: false })
      );
      interactionCollider.position.y = params.height * 0.5;
      scene.add(interactionCollider);

      // --- Raycaster & mouse tracking
      const raycaster = new THREE.Raycaster();
      const mouse = new THREE.Vector2();
      let hoverValid = false;
      const hoverPoint = new THREE.Vector3(); // 현재 프레임 목표
      const hoverPointSmoothed = new THREE.Vector3(); // 보간된 지점

      function updateHoverPoint(ev) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        const hits = raycaster.intersectObject(interactionCollider, false);
        if (hits.length > 0) {
          // 실린더 표면 교차 지점
          hoverPoint.copy(hits[0].point);
          hoverValid = true;
        } else {
          hoverValid = false;
        }
      }

      renderer.domElement.addEventListener("pointermove", updateHoverPoint);
      renderer.domElement.addEventListener("pointerleave", () => {
        hoverValid = false;
      });

      // --- GUI
      const gui = new GUI({ title: "Tornado Controls" });
      gui
        .addColor(params, "color")
        .name("Color")
        .onChange((v) => mat.color.set(v));
      gui
        .add(params, "height", 6, 18, 0.1)
        .name("Height")
        .onChange(syncCollider);
      gui
        .add(params, "baseRadius", 3, 10, 0.1)
        .name("Base Radius")
        .onChange(syncCollider);
      gui
        .add(params, "topRadius", 0.2, 4, 0.1)
        .name("Top Radius")
        .onChange(syncCollider);
      gui.add(params, "swirl", 0.2, 4, 0.05).name("Swirl");
      gui.add(params, "updraft", 0.2, 5, 0.05).name("Updraft");
      gui.add(params, "wobble", 0, 1.5, 0.01).name("Wobble");
      gui.add(params, "innerBoost", 0, 3, 0.05).name("Inner Boost");
      gui.add(params, "pulse", 0, 0.6, 0.01).name("Pulse");
      gui
        .add(params, "dust")
        .name("Dust ring")
        .onChange((v) => (dust.visible = v));

      const fInter = gui.addFolder("Interaction");
      fInter.add(interaction, "enabled").name("Enable");
      fInter.add(interaction, "radius", 0.3, 3.0, 0.05).name("Radius");
      fInter.add(interaction, "strength", 0.1, 2.0, 0.05).name("Strength");
      fInter.add(interaction, "falloff", 1.0, 4.0, 0.1).name("Falloff");
      fInter.add(interaction, "lerp", 0.0, 0.6, 0.01).name("Hover Lerp");

      function syncCollider() {
        scene.remove(interactionCollider);
        interactionCollider.geometry.dispose();
        interactionCollider.material.dispose();
        const col = new THREE.Mesh(
          new THREE.CylinderGeometry(
            params.baseRadius * 1.05,
            params.topRadius * 1.05,
            params.height,
            24,
            1,
            true
          ),
          new THREE.MeshBasicMaterial({ visible: false })
        );
        col.position.y = params.height * 0.5;
        interactionCollider.geometry = col.geometry;
        interactionCollider.material = col.material;
        interactionCollider.position.copy(col.position);
        scene.add(interactionCollider);
      }

      // --- Animation
      let running = true;
      let t = 0;

      const tmp = new THREE.Vector3();
      function animate() {
        if (!running) {
          requestAnimationFrame(animate);
          controls.update();
          renderer.render(scene, camera);
          return;
        }
        const dt = Math.min(0.033, 0.016);
        t += dt;

        // hover 지점 보간(부드럽게)
        if (hoverValid) {
          hoverPointSmoothed.lerp(hoverPoint, interaction.lerp);
        }

        const pos = geom.getAttribute("position");
        const R = interaction.radius;
        const R2 = R * R;
        const s = interaction.strength;

        for (let i = 0; i < params.particles; i++) {
          // 진행
          heights[i] +=
            params.updraft * dt * (0.7 + 0.3 * Math.sin((i * 13.37 + t) * 0.5));
          if (heights[i] > params.height) heights[i] -= params.height;

          // 현재 반경 + 펄스
          const baseR = radiusAt(heights[i]);
          const pulse = 1 + params.pulse * Math.sin(t * 1.6 + i * 0.05);
          const r =
            baseR * pulse * (0.92 + 0.16 * Math.sin(i * 0.23 + t * 0.9));
          radii[i] = r;

          // 회전
          const spin = speeds[i] * params.swirl * dt;
          const angle = t * spin * 8.0 + i;

          // 축 흔들림
          const wobX =
            params.wobble *
            Math.sin(t * 0.9) *
            (1 - heights[i] / params.height);
          const wobZ =
            params.wobble *
            Math.cos(t * 1.1) *
            (1 - heights[i] / params.height);

          let x = Math.cos(angle) * r + wobX;
          let z = Math.sin(angle) * r + wobZ;
          let y = heights[i];

          // --- Interaction: repulsion from mouse hover point
          if (interaction.enabled && hoverValid) {
            // 입자와 hover 지점 거리(월드)
            const dx = x - hoverPointSmoothed.x;
            const dy = y - hoverPointSmoothed.y;
            const dz = z - hoverPointSmoothed.z;
            const d2 = dx * dx + dy * dy + dz * dz;

            if (d2 < R2) {
              // 거리 기반 반발: (1 - d/R)^falloff * strength
              const d = Math.sqrt(d2) + 1e-6;
              const w = Math.pow(1 - d / R, interaction.falloff) * s;

              // 정규화 벡터 * 가중치
              const inv = w / d;
              x += dx * inv;
              y += dy * inv * 0.5; // y방향은 너무 튀지 않게 완만히
              z += dz * inv;
            }
          }

          const idx = i * 3;
          pos.array[idx] = x;
          pos.array[idx + 1] = y;
          pos.array[idx + 2] = z;
        }
        pos.needsUpdate = true;

        // Dust ring 회전
        const dpos = dustGeom.getAttribute("position");
        for (let i = 0; i < dustCount; i++) {
          dustAng[i] += dt * (0.6 + 0.5 * Math.sin(i * 0.07 + t));
          const idx = i * 3;
          dpos.array[idx] = Math.cos(dustAng[i]) * dustRad[i];
          dpos.array[idx + 2] = Math.sin(dustAng[i]) * dustRad[i];
        }
        dpos.needsUpdate = true;

        // Shells: 카메라 항상 바라보도록 & 텍스처 흘림
        shellGroup.children.forEach((mesh, i) => {
          mesh.lookAt(camera.position.x, mesh.position.y, camera.position.z);
          mesh.material.map.offset.y = (t * 0.06 * (i + 1)) % 1;
          mesh.material.opacity = 0.1 + 0.05 * Math.sin(t * 1.2 + i);
        });

        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }
      requestAnimationFrame(animate);

      // --- Resize
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // --- Keyboard helpers
      window.addEventListener("keydown", (e) => {
        if (e.code === "Space") running = !running;
        if (e.key.toLowerCase() === "r") controls.reset();
      });
    </script>
  </body>
</html>
