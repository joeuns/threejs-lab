<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <title>Three.js Tornado Minimal (Module)</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #e4b5b5;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

      // 장면/카메라/렌더러
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(10, 8, 14);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 5, 0);

      // 라이트
      scene.add(new THREE.AmbientLight(0xffffff, 0.6));
      const dirLight = new THREE.DirectionalLight(0xffffff, 1);
      dirLight.position.set(5, 10, 5);
      scene.add(dirLight);

      // 토네이도 파라미터
      const H = 10,
        R0 = 5,
        R1 = 1,
        N = 3000;

      const pos = new Float32Array(N * 3);
      const ang = new Float32Array(N);
      const spd = new Float32Array(N);
      const ys = new Float32Array(N);

      const radiusAt = (y) => THREE.MathUtils.lerp(R0, R1, y / H);

      for (let i = 0; i < N; i++) {
        const y = Math.random() * H;
        const r = radiusAt(y);
        const a = Math.random() * Math.PI * 2;
        pos[i * 3] = Math.cos(a) * r;
        pos[i * 3 + 1] = y;
        pos[i * 3 + 2] = Math.sin(a) * r;
        ys[i] = y;
        ang[i] = a;
        spd[i] = 0.5 + Math.random() * 1.0;
      }

      const geom = new THREE.BufferGeometry();
      geom.setAttribute("position", new THREE.BufferAttribute(pos, 3));
      const mat = new THREE.PointsMaterial({
        color: 0x99ccff,
        size: 1.0, // <-- 이 값을 1.0 정도로 바꿔보세요
        transparent: true,
        opacity: 0.85,
      });
      const tornado = new THREE.Points(geom, mat);
      scene.add(tornado);

      // 애니메이션
      function animate() {
        requestAnimationFrame(animate);
        const a = geom.getAttribute("position").array;
        for (let i = 0; i < N; i++) {
          ys[i] += 0.03;
          if (ys[i] > H) ys[i] = 0;
          const r = radiusAt(ys[i]);
          ang[i] += spd[i] * 0.02;
          a[i * 3] = Math.cos(ang[i]) * r;
          a[i * 3 + 1] = ys[i];
          a[i * 3 + 2] = Math.sin(ang[i]) * r;
        }
        geom.attributes.position.needsUpdate = true;
        controls.update();
        renderer.render(scene, camera);
      }
      animate();

      // 리사이즈 대응
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
