<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Three.js – Heat Rise / Heat Haze (Minimal)</title>
    <style>
      html,
      body {
        margin: 0;
        height: 100%;
        background: #0b0f14;
        color: #e7ecff;
        font: 14px/1.4 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto,
          Helvetica, Arial;
      }
      #app {
        position: fixed;
        inset: 0;
      }
      .hint {
        position: fixed;
        left: 12px;
        bottom: 12px;
        opacity: 0.8;
        font-size: 12px;
      }
      .hint kbd {
        background: #111827;
        border: 1px solid #394151;
        border-bottom-width: 2px;
        border-radius: 6px;
        padding: 2px 6px;
        font-weight: 600;
      }
    </style>
  </head>
  <body>
    <div id="app"></div>
    <div class="hint">드래그: 회전 · 휠: 줌 · <kbd>Space</kbd>: 정지/재생</div>

    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";

      // --- Renderer / Scene / Camera
      const container = document.getElementById("app");
      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: false,
      });
      renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
      renderer.setSize(innerWidth, innerHeight);
      container.appendChild(renderer.domElement);

      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0b0f14);
      scene.fog = new THREE.FogExp2(0x0b0f14, 0.02);

      const camera = new THREE.PerspectiveCamera(
        55,
        innerWidth / innerHeight,
        0.1,
        500
      );
      camera.position.set(7, 6, 12);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.06;
      controls.target.set(0, 2, 0);

      // --- Lights (태양 느낌)
      const sun = new THREE.DirectionalLight(0xffe2a6, 1.2);
      sun.position.set(-6, 10, 4);
      scene.add(new THREE.AmbientLight(0xffc98a, 0.25));
      scene.add(sun);

      // --- Ground plane (열기의 발원 느낌)
      const ground = new THREE.Mesh(
        new THREE.CircleGeometry(20, 72),
        new THREE.MeshStandardMaterial({
          color: 0x1a2430,
          roughness: 1,
          metalness: 0,
        })
      );
      ground.rotation.x = -Math.PI / 2;
      ground.receiveShadow = true;
      scene.add(ground);

      // --- Rising hot-air particles (위로 올라가는 입자)
      const P = 2400,
        H = 6; // particle count, spawn height range
      const pPos = new Float32Array(P * 3);
      const pSpd = new Float32Array(P);
      const pPhase = new Float32Array(P);
      for (let i = 0; i < P; i++) {
        const r = 0.2 + Math.random() * 2.8; // 가까운 원형 영역에서 발생
        const a = Math.random() * Math.PI * 2;
        pPos[i * 3] = Math.cos(a) * r;
        pPos[i * 3 + 1] = Math.random() * H * 0.2; // 바닥 근처에서 시작
        pPos[i * 3 + 2] = Math.sin(a) * r;
        pSpd[i] = 0.3 + Math.random() * 0.6; // 상승 속도
        pPhase[i] = Math.random() * Math.PI * 2; // 좌우 미세 요동 위상
      }
      const pGeom = new THREE.BufferGeometry();
      pGeom.setAttribute("position", new THREE.BufferAttribute(pPos, 3));
      const pMat = new THREE.PointsMaterial({
        color: 0xffb86b,
        size: 0.06,
        transparent: true,
        opacity: 0.7,
        depthWrite: false,
        blending: THREE.AdditiveBlending,
      });
      const hotAir = new THREE.Points(pGeom, pMat);
      scene.add(hotAir);

      // --- Sky dome (연하게 오렌지 그라데)
      const skyGeo = new THREE.SphereGeometry(60, 32, 16);
      const skyMat = new THREE.ShaderMaterial({
        side: THREE.BackSide,
        uniforms: {
          top: { value: new THREE.Color(0x20354a) },
          bottom: { value: new THREE.Color(0x3a1f12) },
        },
        vertexShader: `varying vec3 vWorld; void main(){ vec4 w = modelMatrix * vec4(position,1.0); vWorld = w.xyz; gl_Position = projectionMatrix * viewMatrix * w; }`,
        fragmentShader: `varying vec3 vWorld; uniform vec3 top; uniform vec3 bottom; void main(){ float h = normalize(vWorld).y*0.5+0.5; vec3 col = mix(bottom, top, smoothstep(0.0,1.0,h)); gl_FragColor = vec4(col,1.0); }`,
      });
      scene.add(new THREE.Mesh(skyGeo, skyMat));

      // --- Postprocess: Heat Haze (렌더타깃 -> 스크린 퀴드)
      const rt = new THREE.WebGLRenderTarget(innerWidth, innerHeight, {
        samples: 0,
      });

      const screenScene = new THREE.Scene();
      const screenCam = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

      const heatUniforms = {
        tDiffuse: { value: null },
        time: { value: 0 },
        intensity: { value: 0.015 }, // 왜곡 강도
        horizon: { value: 0.45 }, // 화면에서 열기 중심 높이(0=아래,1=위)
        falloff: { value: 0.6 }, // 위로 갈수록 약해지는 정도
      };

      const fsQuad = new THREE.Mesh(
        new THREE.PlaneGeometry(2, 2),
        new THREE.ShaderMaterial({
          uniforms: heatUniforms,
          transparent: false,
          vertexShader: `
          varying vec2 vUv;
          void main(){ vUv = uv; gl_Position = vec4(position.xy,0.0,1.0); }
        `,
          fragmentShader: `
          precision highp float;
          varying vec2 vUv; uniform sampler2D tDiffuse; uniform float time; uniform float intensity; uniform float horizon; uniform float falloff;

          // 간단한 해시 기반 노이즈
          float hash(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7))) * 43758.5453); }
          float noise(vec2 p){
            vec2 i = floor(p), f = fract(p);
            float a = hash(i);
            float b = hash(i + vec2(1.0,0.0));
            float c = hash(i + vec2(0.0,1.0));
            float d = hash(i + vec2(1.0,1.0));
            vec2 u = f*f*(3.0-2.0*f);
            return mix(a, b, u.x) + (c - a)*u.y*(1.0 - u.x) + (d - b)*u.x*u.y;
          }
          float fbm(vec2 p){
            float v=0.0; float a=0.5; for(int i=0;i<5;i++){ v += a*noise(p); p*=2.02; a*=0.55; } return v;
          }
          void main(){
            // 열기 강도: 화면 아래쪽에서 강하고 위로 갈수록 감소
            float y = vUv.y;
            float zone = clamp(1.0 - smoothstep(horizon, horizon+falloff, y), 0.0, 1.0);

            // 아지랑이 왜곡 벡터
            vec2 n = vec2(
              fbm(vUv*4.0 + vec2(0.0, time*0.3)),
              fbm(vUv*4.0 + vec2(5.2, time*0.28))
            );
            vec2 offset = (n - 0.5) * intensity * (0.3 + 0.7*zone);

            // 굴절(uv 오프셋) 샘플
            vec4 col = texture2D(tDiffuse, vUv + offset);

            // 따뜻한 색감 살짝 추가(아래쪽 중심)
            vec3 warm = vec3(1.0, 0.55, 0.2);
            col.rgb = mix(col.rgb, col.rgb * warm, 0.12 * zone);

            gl_FragColor = col;
          }
        `,
        })
      );
      screenScene.add(fsQuad);

      // --- Animation
      let running = true;
      let t = 0;
      function animate() {
        requestAnimationFrame(animate);
        if (!running) {
          controls.update();
          renderer.setRenderTarget(null);
          renderer.render(scene, camera);
          return;
        }

        const dt = 0.016;
        t += dt;
        heatUniforms.time.value = t;

        // 입자 업데이트: 위로 상승 + 약간의 좌우 출렁임
        const arr = pGeom.getAttribute("position").array;
        for (let i = 0; i < P; i++) {
          const idx = i * 3;
          // 좌우 미세 요동 (열기 흐름)
          const sway =
            0.02 * Math.sin(t * 1.2 + pPhase[i]) +
            0.015 * Math.cos(t * 1.7 + pPhase[i] * 1.3);
          arr[idx] += sway; // x
          arr[idx + 1] += pSpd[i] * dt; // y 상승
          if (arr[idx + 1] > 3.5 + Math.random() * 1.5) {
            // 재스폰: 바닥 근처로 내림
            const r = 0.2 + Math.random() * 2.8;
            const a = Math.random() * Math.PI * 2;
            arr[idx] = Math.cos(a) * r;
            arr[idx + 1] = Math.random() * 0.2;
            arr[idx + 2] = Math.sin(a) * r;
          }
        }
        pGeom.attributes.position.needsUpdate = true;

        // 태양 강도 천천히 증가/감소 (열감)
        sun.intensity = 1.1 + Math.sin(t * 0.25) * 0.25;
        sun.color.setHSL(0.1 + 0.02 * Math.sin(t * 0.15), 0.9, 0.7);

        // 1) 씬을 렌더타깃에 렌더
        renderer.setRenderTarget(rt);
        renderer.render(scene, camera);

        // 2) 포스트(heat haze)
        renderer.setRenderTarget(null);
        heatUniforms.tDiffuse.value = rt.texture;
        renderer.render(screenScene, screenCam);

        controls.update();
      }
      requestAnimationFrame(animate);

      // --- Resize
      addEventListener("resize", () => {
        camera.aspect = innerWidth / innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(innerWidth, innerHeight);
        const newRT = new THREE.WebGLRenderTarget(innerWidth, innerHeight, {
          samples: 0,
        });
        rt.dispose();
        Object.assign(rt, newRT); // 간단 교체
      });

      // --- Keys
      addEventListener("keydown", (e) => {
        if (e.code === "Space") running = !running;
      });
    </script>
  </body>
</html>
